#!/usr/bin/perl
# Written by Erich Weiler
# Report on BD2K AWS spending and email report
use strict;
use warnings;
use lib '/usr/lib64/perl5/lib/perl5';
use Amazon::S3;
use File::Spec;
use File::Temp;
use IO::Uncompress::Gunzip ( 'gunzip', '$GunzipError' );
use JSON;
use List::Util 'sum';
use Text::CSV;
use Time::Piece;
use Time::Seconds;

chdir('/root/aws-reporting');
my $workdir = File::Temp::tempdir( CLEANUP => 1 );

# === Load configuration ===
my $config = do "/root/aws-reporting/config.pl";
die "Error parsing config file: $@" if $@;
die "Error reading config file: $!" unless defined $config;

# === Calculate dates (...is this now?) ===
# Billing data lags by one day, so generate yesterday's report by default
my $report_date =
    defined $ARGV[0] ? $ARGV[0] : ( localtime() - ONE_DAY )->ymd;
my $report_date_obj = localtime->strptime( $report_date, '%Y-%m-%d' );
my $this_month      = $report_date_obj->strftime('%Y%m01');
my $next_month      = ( $report_date_obj + ONE_MONTH )->strftime('%Y%m01');

# === Download report manifest and archive ===
my $report_prefix = "$config->{aws}{prefix}/$config->{aws}{report_name}/";
$report_prefix .= "$this_month-$next_month";
my $manifest_name       = "$config->{aws}{report_name}-Manifest.json";
my $manifest_path       = "$report_prefix/$manifest_name";
my $local_manifest_path = File::Spec->catfile( $workdir, $manifest_name );
my $s3                  = Amazon::S3->new(
    {   aws_access_key_id     => $config->{aws}{access_key},
        aws_secret_access_key => $config->{aws}{secret_key},
        secure                => 1,
        retry                 => 1,
    }
);
my $bucket = $s3->bucket( $config->{aws}{bucket} );

my $is_first_day = localtime->strftime("%d") eq "01";

# This file is overwritten by AWS whenever a new report is generated with
# the path to the latest report.
unless (
    $bucket->get_key_filename( $manifest_path, undef, $local_manifest_path ) )
{
    # On the first day of the month, billing data may not be available until
    # late in the day. If the script is run early in the day, it would fail.
    # The workaround we use is to not raise an error if a report isn't
    # available at runtime on the first day of the month. (It's easy enough
    # to generate a report for the first day after the fact if we miss it.)
    if ($is_first_day) {
        warn "s3: no such key $manifest_path, expecting it later";
        exit 0;
    }
    else {
        die "s3: no such key $manifest_path, stopped";
    }
}
my $manifest_data = do {
    local $/ = undef;
    open my $manifest_fh, "<:encoding(utf8)", $local_manifest_path
        or die "$local_manifest_path: $!, stopped";
    <$manifest_fh>;
};
my $manifest = decode_json $manifest_data;

# Reports that are sufficiently large can be split into multiple files.
# That is not the case for us right now.
my $archive_path       = $manifest->{"reportKeys"}[0];
my $local_archive_path = File::Spec->catfile( $workdir, "report.gz" );
$bucket->get_key_filename( $archive_path, undef, $local_archive_path )
    or die "s3: no such key $archive_path, stopped";
my $local_report_path = File::Spec->catfile( $workdir, "report.csv" );
gunzip $local_archive_path => $local_report_path
    or die "$local_archive_path: $GunzipError, stopped";

# === Parse CSV ===
# my %service_by_account = {
#     12345678 => {
#         "AWS Simple Storage Service" => 0.12343,
#         "AWS Key Management Service" => 1.5324,
#     }
# }
my ( %service_by_account, %service_by_account_today );

# my %ec2_owner_by_account = {
#     12345678 => {
#         "owner@example.com" => 5.242,
#         "owner2@example.com" => 0.013,
#     }
# }
my %ec2_owner_by_account;

# my %ec2_by_name = {
#     "my-name-tag" => 82.666,
#     "(untagged)" => 393933.21,
# }
my %ec2_by_name;

my $csv = Text::CSV->new( { binary => 1, auto_diag => 1, strict => 1 } );
open my $report, "<:encoding(utf8)", $local_report_path
    or die "$local_report_path: $!, stopping";
my @cols = @{ $csv->getline($report) };
my $row  = {};
$csv->bind_columns( \@{$row}{@cols} );
while ( $csv->getline($report) ) {
    my $account_id = $row->{"lineItem/UsageAccountId"};
    my $service    = $row->{"product/ProductName"};
    my $amount     = $row->{"lineItem/BlendedCost"};
    my $date       = substr $row->{"lineItem/UsageEndDate"}, 0, 10;

    # First 10 chars of ISO8601 datetime is the date, which we can lex sort

    if ( $date eq $report_date ) {
        $service_by_account_today{$account_id}->{$service} += $amount;
        $service_by_account{$account_id}->{$service}       += $amount;
        if ( $service eq "Amazon Elastic Compute Cloud" ) {
            my $owner = $row->{"resourceTags/user:Owner"};
            my $name  = $row->{"resourceTags/user:Name"};
            if ( not( defined $name ) or $name eq "" ) {
                $ec2_by_name{"(untagged)"} += $amount;
            }
            else {
                $ec2_by_name{$name} += $amount;
            }
            if ( not( defined $owner ) or $owner eq "" ) {
                $ec2_owner_by_account{$account_id}{"(untagged)"} += $amount;
            }
            else {
                $ec2_owner_by_account{$account_id}->{$owner} += $amount;
            }
        }
    }
    elsif ( $date lt $report_date ) {
        $service_by_account{$account_id}->{$service} += $amount;
    }
}
close $report or warn "$local_report_path: $!";

my $warning_threshold =
    defined ${config}->{report}{warning_threshold}
    ? ${config}->{report}{warning_threshold}
    : -1;

# print_diff(amount) to print an amount, with highlighting if amount is large
# print_diff(amount, warnflag) to print an amount, without highlighting
sub print_diff {
    my ( $amount, $nowarn ) = @_;
    my $warn = $warning_threshold > 0 && !defined $nowarn;

    if ( not( defined $amount ) or $amount eq "" ) {
        return "";

    }
    if ( $warn and $amount > $warning_threshold ) {
        return sprintf( '<span class="unusual">$%.2f</span>', $amount );
    }

    # Ignore sufficiently small amounts
    elsif ( $amount > 0.01 ) {
        return sprintf( '$%.2f', $amount );
    }
    elsif ( $amount < -0.01 ) {

        # A negative value is unlikely but possible in the event of, for
        # example, a credit from AWS
        my $absolute = sprintf( '-$%.2f', abs($amount) );
        return "<span class='unusual'>$absolute</span>";
    }
}

# === Generate email ===
# Rearrange account listing so we can display it alphabetically
my @accounts_sorted = sort {
    lc ${config}->{aws}{accounts}{$a} cmp lc ${config}->{aws}{accounts}{$b}
} keys %service_by_account;

# Write email to disk first so that we don't send out a borked email if this
# script fails before completion
my $local_email_draft_path = File::Spec->catfile( $workdir, 'mailtmp.txt' );
open my $MAIL, '>:encoding(utf8)', $local_email_draft_path
    or die "$local_email_draft_path: $!, stopped";
my $subject    = "AWS Report for " . $report_date_obj->strftime('%B %d, %Y');
my $report_ymd = $report_date_obj->ymd('/');
my $report_mth = $report_date_obj->strftime('%Y/%m');

# Styles are custom and cherry-picked from pure-css 1.0.1
# For styles to show in gmail, they must be in <head> and not <body>
print $MAIL "Mime-Version: 1.0
Content-Type: text/html; charset='UTF-8'
To: " . join( ',', @{ $config->{report}{recipients} } ) . "
From: $config->{report}{from}
Subject: $subject

<!doctype html>
<html lang='en'>
<head>
    <meta charset='utf-8'>
    <title>$subject</title>
    <style type='text/css'>
        td + td, th + th { text-align: right; }  /* All columns except first align right */
        table {
            border-collapse: collapse;
            border-spacing: 0;
            empty-cells: show;
            border: 1px solid #cbcbcb;
        }
        thead {
            background-color: #e0e0e0;
            color: #000;
            text-align: left;
            vertical-align: bottom;
        }
        th, td {
            border-width: 0 0 1px 0;
            border-bottom: 1px solid #cbcbcb;
            font-size: inherit;
            margin: 0;
            overflow: visible;
            padding: .5em 1em;
        }
        td { background-color: transparent; }
        caption {
            color: #000;
            padding: 1em 0;
            text-align: center;
            font: italic 85%/1 arial,sans-serif;
        }
        body {
            margin: 1em;
            font-family: sans-serif;
            -webkit-text-size-adjust: 100%;
            ms-text-size-adjust: 100%;
        }
        a { background-color: transparent }
        h1 { font-size:2em; margin:.67em 0; }
        tbody > tr:hover, tfoot > tr:hover { background-color: #f2f2f2; }
        tfoot { font-weight: 700; }
        .unusual { font-weight: 700; color: red; }
    </style>
</head>
<body>
Amazon Web Services Report for "
    . $report_date_obj->strftime('%A, %d %B %Y') . "<br>
<h2>Totals by account</h2>
<table>
    <thead>
        <tr>
            <th>Account</th>
            <th>$report_mth</th>
            <th>$report_ymd</th>
        </tr>
    </thead>
    <tbody>";
my $all_accounts_total = 0;
my $all_accounts_today = 0;

foreach my $account_id (@accounts_sorted) {
    my $account_total = sum values %{ $service_by_account{$account_id} };
    my $account_today =
        sum values %{ $service_by_account_today{$account_id} };
    $all_accounts_total += defined $account_total ? $account_total : 0;
    $all_accounts_today += defined $account_today ? $account_today : 0;
    my $account_name = $config->{aws}{accounts}{$account_id};
    if ( !defined $account_name ) {
        $account_name = "(unconfigured account)";
    }
    print $MAIL "\
        <tr>
            <td><a href='#$account_name'>$account_name</a></td>
            <td>" . sprintf( '$%.2f', $account_total ) . "</td>
            <td>" . print_diff($account_today) . "</td>
        </tr>";
}
print $MAIL "\
    </tbody>
    <tfoot>
        <tr>
            <td>Grand total</td>
            <td>" . sprintf( '$%.2f', $all_accounts_total ) . "</td>
            <td>"
    . print_diff( $all_accounts_today, 1 ) . "</td>
        </tr>
    </tfoot>
</table>";

foreach my $account_id (@accounts_sorted) {
    my $account_name = $config->{aws}{accounts}{$account_id};
    next if !defined $account_name;

    # To get anchor links to function properly in Gmail, we need to use
    # a[href][name] syntax. For the record, this is:
    #   1. Not compliant with the HTML5 standard, which does not specify a
    #      `name` attribute for <a>
    #   2. Not compliant with any HTML standard, as "XML empty element syntax
    #      isn't supported in any flavor of HTML served as text/html"
    #   3. Is explicitly recommended against in Google's own semantic markup
    #      guidelines.
    #   4. Not documented anywhere in Google's reference for HTML content in
    #      emails.
    print $MAIL "<a name='$account_name' id='$account_name'></a>";
    print $MAIL "<h2>Report for account $account_name</h2>";

    my $ec2_total =
        $service_by_account{$account_id}{"Amazon Elastic Compute Cloud"};
    my $ec2_total_today = $service_by_account_today{$account_id}
        {"Amazon Elastic Compute Cloud"};
    if ( defined $ec2_total ) {
        print $MAIL "\
        <table>
            <caption>EC2 Breakdown by Owner</caption>
            <thead>
                <tr>
                    <th>Owner</th>
                    <th>$report_mth</th>
                </tr>
            </thead>
            <tbody>";
        foreach
            my $owner ( sort keys %{ $ec2_owner_by_account{$account_id} } )
        {
            my $amount = sprintf( '$%.2f',
                $ec2_owner_by_account{$account_id}{$owner} );
            print $MAIL "<tr><td>$owner</td><td>$amount</td></tr>\n";
        }
        print $MAIL "\
            </tbody>
            <tfoot>
                <tr>
                    <td>Grand total</td>
                    <td>" . sprintf( '$%.2f', $ec2_total ) . "
                    <br>(" . print_diff($ec2_total_today) . ")</td>
                </tr>
            </tfoot>
        </table>
        <br>";
    }
    print $MAIL "\
    <table>
        <thead>
            <tr>
                <th>Service</th>
                <th>$report_mth</th>
                <th>$report_ymd</th>
            </tr>
        </thead>
        <tbody>";

service:
    foreach my $service ( sort keys %{ $service_by_account{$account_id} } ) {
        my $cost       = $service_by_account{$account_id}{$service};
        my $cost_today = $service_by_account_today{$account_id}{$service};
        next service if ( $cost < 0.01 );
        print $MAIL "
            <tr>
                <td>$service</td>
                <td>" . sprintf( '$%.2f', $cost ) . "</td>
                <td>" . print_diff($cost_today) . "</td>
            </tr>";
    }

    my $account_total = sum values %{ $service_by_account{$account_id} };
    my $account_total_today =
        sum values %{ $service_by_account_today{$account_id} };
    print $MAIL "
        </tbody>
        <tfoot>
            <tr>
                <td>Grand total</td>
                <td>" . sprintf( '$%.2f', $account_total ) . "</td>
                <td>" . print_diff($account_total_today) . "</td>
            </tr>
        </tfoot>
    </table>";
}

print $MAIL '<h2>Project-based accounting based on the "Name" tag</h2>
<table>
    <thead>
        <tr>
            <th>Tag</th>
            <th>Amount</th>
        </tr>
    </thead>
    <tbody>';
foreach my $owner ( sort keys %ec2_by_name ) {
    my $amount = sprintf( '$%.2f', $ec2_by_name{$owner} );

    # It's important that we add a newline at the end here; Gmail (or maybe
    # SMTP, it's unclear to me) will automatically split lines that are too
    # long, and we have a lot of tags. This can cause some tags to be
    # interpreted as text (i.e. content and not markup) which will bork the
    # formatting of the table. And that's not good.
    print $MAIL "<tr><td>$owner</td><td>$amount</td></tr>\n";
}
print $MAIL "
    </tbody>
</table>
<hr>
Source code for this report is available on
<a href='https://github.com/ucsc-cgp/cloud-billing-report'>GitHub</a>. You
can report <a href='https://github.com/ucsc-cgp/cloud-billing-report/issues'>
issues</a> there, too.
</body></html>";
close $MAIL;

if ( defined $ENV{"REPORT_DEBUG"} ) {
    system "cp $local_email_draft_path report.html";
}
else {
    system "/usr/sbin/sendmail -t < $local_email_draft_path";
}
